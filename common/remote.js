

function poll(fn, timeout, interval) {
  var endTime = Number(new Date()) + (timeout || 2000);
  interval = interval || 100;
  console.log(`endTime: ${new Date(endTime)}`);
  var checkCondition = async function (resolve, reject) {
    var result = await fn();
    console.log(`result: ${JSON.stringify(result)}`);
    if (result) {
      resolve(result);
    }
    else if (Number(new Date()) < endTime) {
      console.log(`new timeout: ${new Date(endTime)}`);
      setTimeout(checkCondition, interval, resolve, reject);
    }
    else {
      console.log(`Error: ${arguments}`);
      reject(new Error('timed out for ' + fn + ': ' + arguments));
    }
  };

  return new Promise(checkCondition);
}


function getAddress() {
  const server = localStorage.getItem("server_address");
  const port = localStorage.getItem("server_port");
  return server + ":" + port;
}

/**
 * If server public key is known: 
 * BaseKey + OneTimeKey = TransportKey
 * OneTimeKey is sent encrypted with the pubkey of the server
 * 
 * If serer public key is unknown (only in linking phase) we don't have a baseKey and use a linking sessionKey:
 * SesssionKey (generated by client) = TransportKey
 * 
 * @param {*} message 
 * @param {*} sendResponse 
 */
async function remoteCall(message, sendResponse) {
  const webClientId = localStorage.getItem("web_client_id");

  const linked = localStorage.getItem("linked");
  let request;
  if (linked) {
    const appPublicKey = await getKey("app_public_key");
    const oneTimeKey = await generateAesKey();
    const oneTimeKeyAsArray = await aesKeyToArray(oneTimeKey);
    const encOneTimeKey = await encryptWithPublicKey(appPublicKey, oneTimeKeyAsArray);
 
    const baseKey = await getKey("base_key");
    const baseKeyAsArray = await aesKeyToArray(baseKey);
    console.log("baseKey=" + bytesToBase64(baseKeyAsArray));
  
    const transportKeyAsArray = await hashKeys(baseKey, oneTimeKey); 
    const transportKey = await arrayToAesKey(transportKeyAsArray);
    console.log("transportKey=" + transportKeyAsArray);

    const envelope = await encryptMessage(transportKey, JSON.stringify(message));

    request = {
      encOneTimeKey: bytesToBase64(encOneTimeKey), 
      envelope: envelope,
    };
  }
  else {
    const sessionKey = await generateOrGetSessionKey(); 
    const sessionKeyAsArray = await aesKeyToArray(sessionKey);
    console.log("sessionKey=" + bytesToBase64(sessionKeyAsArray));
    console.log("transportKey/sessionKey=" + sessionKeyAsArray);


    const envelope = await encryptMessage(sessionKey, JSON.stringify(message));
    request = {
      envelope: envelope,
    };
  }

  console.log("sending plain request:", JSON.stringify(message));  
  console.log("sending request:", JSON.stringify(request));

  const address = getAddress();
  console.log("fetch from", address);


  fetch('http://' + address + '/', {
      method: 'POST',
      headers: { 
        "X-WebClientId": webClientId, 
        "Content-Type": "application/json",
        "Accept": "application/json",
      },
      body: JSON.stringify(request)
    }).then(res => {
      console.log("received HTTP Status: " + res.status);

      if (res.status != 200) {
        console.warn("Unsuccessful! Reason: " + JSON.stringify(res.text));
        sendResponse({ response: null });
        return null;
      }

      return res.text();
    }).then(async res => {

      console.log("received body: " + res);
      if (res == null) {
        return null;
      }

      var response;
      try {
        response = JSON.parse(res);
      }
      catch (e) {
        console.warn("cannot parse response", e)
        response = {
          "raw": res
        };
      }

      const keyPair = await getKey("client_keypair");
      const encOneTimeKey = base64ToBytes(response.encOneTimeKey);
      console.log("encOneTimeKey=" + encOneTimeKey);
      const decOneTimeKeyAsArray = await decryptWithPrivateKey(keyPair.privateKey, encOneTimeKey);
      console.log("decOneTimeKeyAsArray=" + decOneTimeKeyAsArray);
      let transportKeyAsArray;
      if (linked) {
        // derive transport key (local base key + sent encrypted one-time key)
        transportKeyAsArray = await hashKeys(baseKeyAsArray, decOneTimeKeyAsArray);
      }
      else {
        // in linking phase the client doesn't have a basekey and uses the previously shared session key as second key
        const sessionKey = await generateOrGetSessionKey(); 
        const sessionKeyAsArray = await aesKeyToArray(sessionKey);        
        // derive transport key (session key + sent encrypted one-time key)
        transportKeyAsArray = await hashKeys(sessionKeyAsArray, decOneTimeKeyAsArray);
      }

      console.debug("transportKey", transportKeyAsArray);

      const transportKey = await arrayToAesKey(transportKeyAsArray);
      // decrypt response
      return decryptMessage(transportKey, response.envelope);

    }).then(decryptedPayload => {
      console.debug("decrypted response", decryptedPayload);

      if (decryptedPayload == null) {
        return null;
      }

      var response;
      try {
        response = JSON.parse(decryptedPayload);
      }
      catch (e) {
        console.warn("cannot parse decryptedPayload", e)
        response = {
          "raw": res
        };
      }

      sendResponse({ response: response });
    }).catch(e => {
      console.error("HTTP failed:", e);
      sendResponse({ response: null });
    });
}
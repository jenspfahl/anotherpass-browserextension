

function poll(fn, timeout, interval) {
  var endTime = Number(new Date()) + (timeout || 2000);
  interval = interval || 100;
  console.log(`endTime: ${new Date(endTime)}`);
  var checkCondition = async function (resolve, reject) {
    var result = await fn();
    console.log(`result: ${JSON.stringify(result)}`);
    if (result) {
      resolve(result);
    }
    else if (Number(new Date()) < endTime) {
      console.log(`new timeout: ${new Date(endTime)}`);
      setTimeout(checkCondition, interval, resolve, reject);
    }
    else {
      console.log(`Error: ${arguments}`);
      reject(new Error('timed out for ' + fn + ': ' + arguments));
    }
  };

  return new Promise(checkCondition);
}


function getAddress() {
  const server = localStorage.getItem("server_address");
  const port = localStorage.getItem("server_port");
  return server + ":" + port;
}

/**
 * If server public key is known: 
 * BaseKey + OneTimeKey = TransportKey
 * OneTimeKey is sent encrypted with the pubkey of the server
 * 
 * If serer public key is unknown (only in linking phase):
 * BaseKey (generated by client) = TransportKey
 * 
 * @param {*} message 
 * @param {*} sendResponse 
 */
async function remoteCall(message, sendResponse) {
  const webClientId = localStorage.getItem("web_client_id");

  const baseKey = await generateOrGetBaseKey(); 
  const baseKeyAsArray = await aesKeyToArray(baseKey);
  console.log("baseKey=" + bytesToBase64(baseKeyAsArray));

  const linked = localStorage.getItem("linked");
  let request;
  if (linked) {
    const appPublicKey = await getKey("app_public_key");
    const oneTimeKey = await generateAesKey();
    const oneTimeKeyAsArray = await aesKeyToArray(oneTimeKey);
    const encOneTimeKey = await encryptWithPublicKey(appPublicKey, oneTimeKeyAsArray);
 
    const transportKey = hashKeys(baseKey, oneTimeKey);
    const envelope = await encryptMessage(transportKey, JSON.stringify(message));

    request = {
      encOneTimeKey: bytesToBase64(encOneTimeKey), 
      envelope: envelope,
    };
  }
  else {
    const envelope = await encryptMessage(baseKey, JSON.stringify(message));
    request = {
      envelope: envelope,
    };
  }

  console.log("sending plain request:", JSON.stringify(message));  
  console.log("sending request:", JSON.stringify(request));

  const address = getAddress();
  console.log("fetch from", address);


  fetch('http://' + address + '/', {
      method: 'POST',
      headers: { 
        "X-WebClientId": webClientId, 
        "Content-Type": "application/json",
        "Accept": "application/json",
      },
      body: JSON.stringify(request)
    }).then(res => {
      console.log("received HTTP Status: " + res.status);

      if (res.status != 200) {
        console.warn("Unsuccessful! Reason: " + JSON.stringify(res.text));
        return null;
      }

      return res.text();
    }).then(async res => {

      console.log("received body: " + res);

      var response;
      try {
        response = JSON.parse(res);
      }
      catch (e) {
        console.warn("cannot parse response", e)
        response = {
          "raw": res
        };
      }

      const encOneTimeKey = base64ToBytes(response.encOneTimeKey);
      const decOneTimeKeyAsArray = await decryptWithPrivateKey(keyPair.privateKey, encOneTimeKey);
    
      // derive transport key (local base key + sent encrypted one-time key)
      const transportKey = hashKeys(baseKey, decOneTimeKeyAsArray);

      // decrypt response
      return decryptMessage(transportKey, response.envelope);
    }).then(decryptedPayload => {
      console.debug("decrypted response", decryptedPayload);

      var response;
      try {
        response = JSON.parse(decryptedPayload);
      }
      catch (e) {
        console.warn("cannot parse decryptedPayload", e)
        response = {
          "raw": res
        };
      }

      sendResponse({ response: response });
    }).catch(e => {
      console.error("HTTP failed:", e);
      sendResponse({ response: null });
    });
}